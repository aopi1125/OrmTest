## Realm 
Realm是一个 MVCC 数据库 ，开始是用 C++ 编写的。MVCC 指的是多版本并发控制。[DOC](https://realm.io/docs/ "DOC")
### Realm的优点
- 采用了 零拷贝 架构
- Realm 的核心是用非常快的 C++ 写的，它把 C++ 对象映射到磁盘上。
- 简单易用速度快跨平台高级功能可视化开源
- 以二叉树结构存储数据
- 支持加密，格式化查询，流式API，JSON，数据变更通知等等。
- 官方提供了一个名为「Realm Browser」轻量级的数据库查看工具(目前还只支持macOS平台)
- Realm是作为一个Gradle插件安装的。
- 对于底层数据而言，RealmObject是实时的，自动更新的

### Realm的不足
- **体积**：引入Realm之后，在不做任何处理的情况下，APK体积增大了一个非常恐怖的数字 5.6M。
- **数据类型**：Realm要求当前Bean对象必须直接继承RealmObject，侵入性非常强。使用RealmList时，泛型T类型必须是直接继承了RealmObject的类型
- Realm是不支持主键自增长的，所以，我们需要自己维护一个PrimaryKey来约束主键。
- **线程限制**：如果你在UI线程获取到了当前Realm对象，在异步线程中使用当前Realm对象进行操作，就会抛出异常了。RealmObject也是如此。所以，异步很重要。
另外，在调用了Realm.close()方法之后，所获取的对象就不能再访问了，所以，在获取到了RealmObject之后，官方提供了一个COPYFROMREALM来复制一份实例供我们使用。
- 不支持反向link的查询. (见前面链式查询部分的介绍).
- 不支持级联删除. 即从数据库中删除一个对象的时候, 不会删除其中RealmObject子类或RealmList类型的字段在数据库中对应的数据. Issue #1104, Issue #2717. 这点也可以理解, 因为model之间的关系可能是多对多的. 所以需要实现级联删除的地方需要手动处理.
 

----------


		为什么 Realm 对象不能在线程间传递？
这是因为隔离性和数据一致性。  
因为 Realm 是基于零拷贝架构，所有对象是鲜活的而且自动更新。如果 Realm 允许对象可在线程间共享，Realm 会无法确保数据的一致性，因为不同的线程会在不确定的什么时间点同时改变对象的数据。这样数据很快就不一致了。一个线程可能需要写入一个数据而另一个线程也打算读取它，反过来也可能。这很快就会变得有问题了，而且你不能够在相信哪个线程能有正确的数据了。   
是的，这可以通过许多方法来解决，一个常用的方法就是锁住对象，存储器和访问器。虽然这能工作，但是锁会变成一个头疼的性能瓶颈。除了性能，锁的其他问题也很明显，因为锁 —— 一个长时间的后台写事务会阻塞 UI 的读事务。如果我们采用锁机制，我们会失去太多的 Realm 可提供的速度优势和数据一致性的保证。  
因此，唯一的限制就是 Realm 对象在不同的线程间是不能共享的。如果你需要在另外一个线程中获取同样的数据，你只需要在该线程里面重新查询。或者，更好的方法是，用 Realm 的响应式架构监听变化！记住 - 各个线程的所有对象都是自动更新的 - Realm 会在数据变化时通知你。你只需要对这些变化做出响应就可以了

